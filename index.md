### About me

My name is Lucy Stent, I am 24 and about to start my second year of a Bsc in computer science at Falmouth University, the year before coming to Falmouth University I completed Cert.HE for IT including Robotics and Maths achieving a distinction grade from the Open University.

At 19 I was awarded a BTEC (at PPM grade) in Land management from Falmouth marine school and worked for some time as a zookeeper before deciding to take the leap and follow my dream to becoming a game programmer.

I left main stream school at 14 as I have dyslexia and dyspraxia and falling behind in most classes compared to my peers, I was then educated by Oxford Open Learning and received a B in double science, C in English, C in Math and B in Psychology.

# **Portfolio**

## **Games**

### Slime EVO

_(Built using python and pygame)_

Slime Evo is a platform game in which the player takes control of a glob of slime and traverses levels by manipulating the size of the slime.

![Image]({{https://github.com/lstent/lstent.github.io/blob/master}}{{https://github.com/lstent/lstent.github.io/blob/master}}/Pictures/Slime%20EVO.jpg)

Built by a team of 4 programmers, my contribution was to make the collision for the slime to stand on the platforms and gravity for the slime to fall onto said platforms.

### Street Cat Fighter and Controller

_(Built using C++, Unreal Engine and Arduino)_

Street cat fighter is a fighting game in which the player controls a new cat in the neighbourhood which fights the other cats to gain territory and eventually takes over the whole town, the player cat is controlled by pressing buttons on a cat teddy e.g. the right arm is claw, the left arm is block, the mouth is bite and the tail is stun.

![Image]({{https://github.com/lstent/lstent.github.io/blob/master}}
{{https://github.com/lstent/lstent.github.io/blob/master}}/Pictures/Street%20cat%20fighter.png)

I built the game and controller over several months, here is a [link](https://www.youtube.com/watch?v=tlWThEZve9o) to the controller in use.

### Standby

_(Built using Unreal engine)_

Standby is a first person sci-fi horror set in the future when homes are controlled by robot servants, the player is the inventor of a new robot butler which had gone rogue and now seeks to kill its master, the player has to interact with objects in the environment to distract the robot and also find key card to unlock doors and eventually destroy the server in the basement to kill the robot.

![Image]({{https://github.com/lstent/lstent.github.io/blob/master}}
{{https://github.com/lstent/lstent.github.io/blob/master}}/Pictures/Standby.png)

This game was created by a team of writers, artists, animators, designers and programmers. I programmed the AI for the Robot, which included the robot searching randomly for the player, chasing the player when they come into sight, movement speed depending on the situation, hearing the player depending on how fast the player moved and damage to the player when the robot entered the players collision capsule which takes a large chunk of health then slowly drains the rest if the player remains in the collision state.

I also programmed the torch attached to the phone and the axe which lighted up when the player was near which also had to be picked up for the player to destroy the server and win the game.

I created the controls screen and the credits screen creating clickable links for them from the start screen and pause menu.

## **Papers**

### What are the advantages and disadvantages to using behaviour trees in simple NPC programming for digital games?

One of the deciding factors on how well a game is rated is the behaviour of the NPC AI within the game, their movement and senses have to be realistic, e.g. if the NPC enemy is supposed to detect the player with sight, it would be wrong for the player to be detected through a wall. Therefore programming an NPC is one of the most important parts of producing a game and should be simplified as much as possible, unfortunately there are many different ways to programme an AI controlled character, of which behaviour trees is one of the most recent methods, this paper looks into the advantages and disadvantages of simple NPC programming using behaviour trees. The conclusion discusses whether the advantages of behaviour trees outweigh the disadvantages and the future of NPC AI programming.

[Link](https://github.com/lstent/comp160-engineering/blob/master/Software%20engineering%20essay.pdf) to the full paper.

### Undergraduate students lack the maturity skills in order to use Agile methodologies, such as Scrum efficiently

This paper discusses the implementation of Agile methodologies (focusing on Scrum) in non-professional teams, particularly within the classroom setting, when Scrum can quickly become biased. This could refer, for example to one group member who may be given the majority of the workload, or the more complex of the Scrum tasks, while another member is given an easier task to complete in the same time period. This is in comparison to Agile being used in a professional games industry, where there is a more mature view of the working relationship. After outlining these problems, this paper presents possible solutions in the form of practice collaboration tasks, teaching the correlation of daily stand up meetings, positivity and team productivity.

[Link](https://github.com/lstent/comp150-agile/blob/master/essay.pdf) to the full paper.

### The history of digital facial replication including methods used and problems that arose

Photorealism is a very important factor to take into account for creating characters for digital games, if the game has an emotional plot line the more realistic the facial expressions of the characters whether happy or sad, the more likely the player will become emotionally invested in the story, the game will feel more immersive. Rockstar Games LA Noire is a good example of using expressions within a digital game as the story involved judging an NPCs expression to decide if what they have said is true or false, is the character angry, happy or upset?

In this paper I looked into the history of digital face replication to find how the methods evolved, the problems the creators experienced. The conclusion summarises what was learnt in those years, the importance of what the authors did and looking at their papers what we can expect in the future.

[Link](https://github.com/lstent/comp130-journal/blob/master/Research%20project.pdf) to the full paper
